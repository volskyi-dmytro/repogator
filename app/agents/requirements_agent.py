"""Requirements enrichment agent using RAG + Claude via OpenRouter."""
import json
import logging
from typing import Literal

from openai import AsyncOpenAI
from pydantic import BaseModel

from app.config import settings
from app.rag.knowledge_base import KnowledgeBase

logger = logging.getLogger(__name__)


class RequirementsOutput(BaseModel):
    enriched_title: str
    acceptance_criteria: list[str]  # Given/When/Then format
    edge_cases: list[str]
    suggested_labels: list[str]
    complexity: Literal["XS", "S", "M", "L", "XL"]
    rag_sources: list[str]
    formatted_comment: str  # Ready to post to GitHub as markdown
    tokens_used: int = 0


class RequirementsAgent:
    """Enriches GitHub issues with structured requirements analysis."""

    def __init__(
        self,
        knowledge_base: KnowledgeBase,
        openrouter_api_key: str | None = None,
        openrouter_model: str | None = None,
    ):
        self.kb = knowledge_base
        self.model = openrouter_model or settings.openrouter_model
        self.llm = AsyncOpenAI(
            base_url=settings.openrouter_base_url,
            api_key=openrouter_api_key or settings.openrouter_api_key,
        )

    async def process(
        self,
        issue_title: str,
        issue_body: str,
        repo: str,
        correlation_id: str,
    ) -> RequirementsOutput:
        """Process a GitHub issue and return enriched requirements.

        Args:
            issue_title: Title of the GitHub issue.
            issue_body: Body text of the issue (may be empty).
            repo: Repository in "owner/repo" format.
            correlation_id: Tracing ID for log correlation.

        Returns:
            RequirementsOutput with structured analysis and a formatted comment.
        """
        # 1. Retrieve relevant KB chunks
        query = f"{issue_title}\n{issue_body or ''}"
        kb_chunks = await self.kb.retrieve("requirements", query, n_results=3)
        rag_context = "\n\n".join([c["text"] for c in kb_chunks])
        rag_sources = [c["id"] for c in kb_chunks]

        # 2. Call LLM with structured output prompt
        prompt = self._build_prompt(issue_title, issue_body, rag_context)

        response = await self.llm.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You are a senior product manager and requirements engineer. "
                        "Return ONLY valid JSON."
                    ),
                },
                {"role": "user", "content": prompt},
            ],
            temperature=0.3,
            response_format={"type": "json_object"},
        )

        tokens_used = response.usage.total_tokens if response.usage else 0
        logger.info(
            "Requirements agent tokens used: %d",
            tokens_used,
            extra={"correlation_id": correlation_id, "repo": repo},
        )

        raw = json.loads(response.choices[0].message.content)
        raw["rag_sources"] = rag_sources
        raw["formatted_comment"] = self._format_comment(raw, self.model)
        raw["tokens_used"] = tokens_used

        return RequirementsOutput(**raw)

    def _build_prompt(self, title: str, body: str, rag_context: str) -> str:
        return f"""Analyze this GitHub issue and enrich it with structured requirements.

ISSUE TITLE: {title}
ISSUE BODY: {body or 'No description provided'}

RELEVANT BEST PRACTICES FROM KNOWLEDGE BASE:
{rag_context}

Return a JSON object with these exact fields:
- enriched_title: Improved, specific story title (start with "As a [user]..." if appropriate)
- acceptance_criteria: Array of 3-5 strings, each a SINGLE pre-formatted string like "Given X, When Y, Then Z" â€” NOT an object, just a plain string
- edge_cases: Array of 3-5 edge cases to consider
- suggested_labels: Array of GitHub labels (e.g. ["bug", "authentication", "high-priority"])
- complexity: One of "XS", "S", "M", "L", "XL" based on INVEST complexity guide"""

    def _format_comment(self, data: dict, model: str) -> str:
        criteria = "\n".join([f"- {c}" for c in data["acceptance_criteria"]])
        edges = "\n".join([f"- {e}" for e in data["edge_cases"]])
        labels = ", ".join([f"`{l}`" for l in data["suggested_labels"]])

        return f"""## RepoGator Requirements Analysis

**Enriched Title:** {data["enriched_title"]}

**Complexity:** `{data["complexity"]}`

### Acceptance Criteria
{criteria}

### Edge Cases to Consider
{edges}

### Suggested Labels
{labels}

---
*Generated by RepoGator Requirements Agent using RAG knowledge base*
*Model: {model}*"""
