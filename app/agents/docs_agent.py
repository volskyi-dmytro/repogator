"""Documentation generation agent using RAG + Claude via OpenRouter."""
import json
import logging

from openai import AsyncOpenAI
from pydantic import BaseModel

from app.config import settings
from app.rag.knowledge_base import KnowledgeBase

logger = logging.getLogger(__name__)


class DocsOutput(BaseModel):
    summary: str
    technical_notes: str
    rag_sources: list[str]
    formatted_comment: str  # Ready to post to GitHub as markdown


class DocsAgent:
    """Generates documentation summaries for GitHub issues and PRs."""

    def __init__(
        self,
        knowledge_base: KnowledgeBase,
        openrouter_api_key: str | None = None,
        openrouter_model: str | None = None,
    ):
        self.kb = knowledge_base
        self.model = openrouter_model or settings.openrouter_model
        self.llm = AsyncOpenAI(
            base_url=settings.openrouter_base_url,
            api_key=openrouter_api_key or settings.openrouter_api_key,
        )

    async def process(
        self,
        title: str,
        body: str,
        diff: str | None,
        repo: str,
        correlation_id: str,
        context_type: str = "issue",
    ) -> DocsOutput:
        """Generate a documentation summary for an issue or PR.

        Args:
            title: Issue or PR title.
            body: Issue or PR body text.
            diff: Optional unified diff for PRs (may be None for issues).
            repo: Repository in "owner/repo" format.
            correlation_id: Tracing ID for log correlation.
            context_type: "issue" or "pull_request" — shapes the prompt.

        Returns:
            DocsOutput with a summary, technical notes, and formatted comment.
        """
        query = f"{title}\n{body or ''}"
        kb_chunks = await self.kb.retrieve("documentation", query, n_results=3)
        rag_context = "\n\n".join([c["text"] for c in kb_chunks])
        rag_sources = [c["id"] for c in kb_chunks]

        prompt = self._build_prompt(title, body, diff, rag_context, context_type)

        response = await self.llm.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You are a technical writer creating clear, concise documentation. "
                        "Return ONLY valid JSON."
                    ),
                },
                {"role": "user", "content": prompt},
            ],
            temperature=0.3,
            response_format={"type": "json_object"},
        )

        tokens_used = response.usage.total_tokens if response.usage else 0
        logger.info(
            "Docs agent tokens used: %d",
            tokens_used,
            extra={"correlation_id": correlation_id, "repo": repo},
        )

        raw = json.loads(response.choices[0].message.content)
        raw["rag_sources"] = rag_sources
        raw["formatted_comment"] = self._format_comment(raw, context_type)

        return DocsOutput(**raw)

    def _build_prompt(
        self,
        title: str,
        body: str,
        diff: str | None,
        rag_context: str,
        context_type: str,
    ) -> str:
        diff_section = ""
        if diff:
            # GitHub has a 65536 byte limit on PR diffs — truncate to avoid API errors
            truncated = diff[:65000] if len(diff) > 65000 else diff
            diff_section = f"\nCODE DIFF:\n{truncated}"

        return f"""Generate documentation for this GitHub {context_type}.

TITLE: {title}
BODY: {body or 'No description provided'}{diff_section}

DOCUMENTATION STANDARDS FROM KNOWLEDGE BASE:
{rag_context}

Return a JSON object with these exact fields:
- summary: A 2-4 sentence plain-English summary of what this {context_type} is about and why it matters
- technical_notes: Bullet-point technical details, caveats, or implementation notes (as a single string with newlines)"""

    def _format_comment(self, data: dict, context_type: str) -> str:
        label = "Issue" if context_type == "issue" else "Pull Request"
        return f"""## RepoGator Documentation Summary

### {label} Summary
{data["summary"]}

### Technical Notes
{data["technical_notes"]}

---
*Generated by RepoGator Docs Agent using RAG knowledge base*"""
